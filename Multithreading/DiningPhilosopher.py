import threadingimport timeimport randomclass Philosopher(threading.Thread):    def __init__(self, name, left_fork, right_fork, cv):        threading.Thread.__init__(self)        self.name = name        self.left_fork = left_fork        self.right_fork = right_fork        self.cv = cv        self.eat_food = False    def run(self):        while True:            time.sleep(random.uniform(1, 3))            if self.eat_food:                break            print('%s is thinking.' % self.name)            with self.cv:                self.cv.wait_for(lambda: not self.left_fork.locked() and not self.right_fork.locked())                self.left_fork.acquire()                self.right_fork.acquire()                print('%s starts eating.' % self.name)            time.sleep(random.uniform(1, 3))            print('%s finishes eating and leaves to think again.' % self.name)            self.eat_food = True            self.left_fork.release()            self.right_fork.release()            with self.cv:                self.cv.notify_all()def main():    forks = [threading.Lock() for _ in range(5)]    cv = threading.Condition()    philosophers_names = ('Akshay', 'Shreya', 'Nayan', 'Vaishali', 'Aayush')    philosophers = [Philosopher(philosophers_names[i], forks[i % 5], forks[(i + 1) % 5], cv) for i in range(5)]    for philosopher in philosophers:        philosopher.start()    time.sleep(10)    for philosopher in philosophers:        philosopher.join()    print("Now we're finishing.")if __name__ == "__main__":    main()