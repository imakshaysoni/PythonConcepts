import threadingimport timeimport randomclass Philosopher:    def __init__(self, name, left_fork, right_fork, cv):        self.name = name        self.left_fork = left_fork        self.right_fork = right_fork        self.eat_food = False        self.condition = cv    def eat(self):        while True:            time.sleep(random.uniform(1, 3))            if self.eat_food:                break            with self.condition:                self.condition.wait_for(lambda: not self.left_fork.locked() and not self.right_fork.locked())                self.left_fork.acquire_lock()                self.right_fork.acquire_lock()                print(f"{self.name} is eating...")            time.sleep(random.uniform(1, 3))            print(f"{self.name} finished eating")            self.eat_food = True            self.left_fork.release()            self.right_fork.release()            with self.condition:                self.condition.notify_all()fork = [threading.Lock() for i in range(0, 5)]cv = threading.Condition()philosophers_name = ["Akshay", "Shreya", "Vaishali", "Nayan", "Aayush"]philosophers = [Philosopher(philosophers_name[i],                            fork[i%5],                            fork[(i+1) %5], cv                            )  for i in range(0, 5)]# Create threads for philosopherphilosopher_threads = []for philosopher in philosophers:    th = threading.Thread(target=philosopher.eat)    philosopher_threads.append(th)for thread in philosopher_threads:    thread.start()for thread in philosopher_threads:    thread.join()print("eating finished")