import concurrent.futuresimport threadingimport timedef demo_function_v1(args=None):    print("Demo Function V1 Started")    time.sleep(1)    print("Demo Function V1 Finished")    return "V1"def demo_function_v2(args=None):    print("Demo Function V2 Started")    time.sleep(2)    print("Demo Function V2 Finished")    return "V2"def demo_function_v3(args=None):    print("Demo Function V3 Started")    time.sleep(3)    print("Demo Function V3 Finished")    return "V3"def demo_function_v4(args):    print(f"Demo Function V4 Started, Args: {args}")    time.sleep(4)    print("Demo Function V4 Finished")    return "V4"# Normal Executionstart_time = time.perf_counter()v1 = demo_function_v1()v2 = demo_function_v2()v3 = demo_function_v3()v4 = demo_function_v4("Input Arguments")print(v1, v2, v3, v4)end_time = time.perf_counter()print(f"Execution Time: {end_time-start_time}")# Output"""        Demo Function V1 Started        Demo Function V1 Finished        Demo Function V2 Started        Demo Function V2 Finished        Demo Function V3 Started        Demo Function V3 Finished        Demo Function V4 Started, Args: Input Arguments        Demo Function V4 Finished        V1 V2 V3 V4        Execution Time: 10.001308100065216"""#  Threadingresult = []t1 = threading.Thread(target=demo_function_v1)t2 = threading.Thread(target=demo_function_v2)t3 = threading.Thread(target=demo_function_v3)t4 = threading.Thread(target=demo_function_v4, args=["Input Argument"])start_time = time.perf_counter()t1.start()t2.start()t3.start()t4.start()end_time = time.perf_counter()print(f"Execution Time: {end_time-start_time}")  # This is the time of start each threading, All are running as of now.# Want to wait for their complete executiont1.join()t2.join()t3.join()t4.join()end_time = time.perf_counter()# print(v1, v2, v3, v4)print(t1.join())print(f"Execution Time: {end_time-start_time}")# Output"""        Demo Function V1 Started        Demo Function V2 Started        Demo Function V3 Started        Demo Function V4 Started, Args: Input Argument        Execution Time: 0.0018319999799132347        Demo Function V1 Finished        Demo Function V2 Finished        Demo Function V3 Finished        Demo Function V4 Finished                Execution Time: 4.002395799965598"""# Observation# Without threading it took 10 seconds, Execution time of each fn 1 + 2 + 3 + 4 == 10 Seconds# WithThreading, it took 4 seconds, Max of Execution Time in all functions: Max(1,2,3,4) => 4 Seconds#  Pythonic Way# concurrent.futurefrom concurrent.futures import ThreadPoolExecutorstart_time = time.perf_counter()list_of_functions = [demo_function_v1, demo_function_v2, demo_function_v3, demo_function_v4]args =[None, None, None, "Input Args"]# using executor.submit()results = []with ThreadPoolExecutor() as executor:    for func, args in zip(list_of_functions, args):        result = executor.submit(func, args)        results.append(result)for result in concurrent.futures.as_completed(results):    print(result.result())# Another better way, Using executor.map()with ThreadPoolExecutor() as executor:    results = executor.map(demo_function_v4, args)  # We cannot pass list of function, only list of arguments.for result in results:    print(result)end_time = time.perf_counter()print(f"Execution Time: {end_time-start_time}")# Output"""    Demo Function V1 Started    Demo Function V2 Started    Demo Function V3 Started    Demo Function V4 Started, Args: Input Args    Demo Function V1 Finished    Demo Function V2 Finished    Demo Function V3 Finished    Demo Function V4 Finished    V4    V2    V1    V3    Execution Time: 4.001942300004885"""